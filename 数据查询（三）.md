## 表的基本连接
```sql
select c.CategoryID, c.CategoryName, p.CategoryID, p.ProduceName, o.OrderID
from Categories as c, Products as p, [Order Details] as o
where c.CategoryID=p.CategoryID
and p.ProductID=o.ProductID
and CategoryName IN ('Beverages','Condiments')
and ProductName like 'c%'
and o.OrderID > 11060
```
> 1.执行from语句，先计算笛卡尔积，列出这两个表中行的所有可能组合<br>
> 2.执行where子句，删除不满足条件的记录<br>
> 3.执行select语句<br>


```
注意：
1.使用SQL Server关键字作为表名、列名时，需要使用'[]'括起来，例如Order作为表明，则需要写成`CREATE TABLE [Order]`
```

## 表的连接类型
### 自连接
自连接是指表与其自身进行连接，在自连接时必须给表取别名，否则产生中间表后会因为表同名而报错
```sql
select t1.OrganizationID AS 父机构编号, t1.OrganizationName AS 父机构名称, t2.OrganizationName AS 子机构名称
from Organization as t1, Organization as t2
where t1.OrganizationID=t2.OrganizationID
```
> 1.执行from子句，根据笛卡尔积得到中间表<br>
> 2.执行where子句，删除重复记录<br>
> 3.执行select子句

### 内连接
内连接也称等等同连接，返回的结果集是两个表中所有相匹配的数据，并舍弃不匹配的数据
`select ... from 表1 [INNER] JOIN 表2 ON <表达式>`
```sql
select Categories.CategoryID, Categories.CategoryName, Products.CategoryID, Products.ProductName
from  Categories JOIN Products
ON  Categories.CategoryID = Products.CategoryID
where CategoryName IN ('Beverages','Condiments')
and ProductName like 'c%'
```
### 外连接
与内连接的区别在于：外连接不仅可以返回两个表都匹配的行，还能返回一边有而另一边没有的行
```sql
select t1.OrganizationID AS 父机构编号, t1.OrganizationName AS 父机构名称, t2.OrganizationName AS 子机构名称
from Organization as t1 FULL [OUTER] JOIN Organnize as t2
ON t1.OrganizationID=t2.OrganizationID
```
`outer可以省略，左外连接就是右边没有的值以null表示，右外连接就是左边没有的以null表示`

## UNION运算符
#### 同一表中相同的字段进行UNION运算
```sql
select ProductName as 产品名称 from Products where ProductID < 4
UNION
select ProductName as 产品名称 from Products where ProductID > 5
```
> 1.执行第一个select放入中间表<br>
> 2.执行第二个select放入中间表<br>
> 3.进行UNION运算，对比两个中间表后删除重复记录

## 多表综合应用
#### 多表连接进行聚合运算
```sql
select o.EmployeeID AS 员工编号,
      COUNT(*) AS 订单总数,
      SUM(od.Quantity*od.UnitPrice) AS 订单总价格
from Orders AS O, [Order Details] AS od
where o.OrderID=od.OrderID
GROUP BY o.EmployeeID
```
> 1.执行from子句，生成笛卡尔积中间表
> 2.执行where子句，删除不满足where的记录
> 3.执行group by 子句
> 4.执行select 子句中的聚合函数`此处的count()是计算每组的总数，而不是整张表的记录数`

#### 多表查询结果查询
```sql
select o.EmployeeID AS 员工编号,
      COUNT(*) AS 订单总数,
      SUM(od.Quantity*od.UnitPrice) AS 订单总价格
from Orders AS O, [Order Details] AS od
where o.OrderID=od.OrderID
GROUP BY o.EmployeeID
ORDER BY  SUM(od.Quantity*od.UnitPrice) DESC,COUNT(*) ASC
```
> ORDER BY 子句是对最后的结果排序，所以是执行在select之后

#### having对结果的删选
```sql
select o.EmployeeID AS 员工编号,
      COUNT(*) AS 订单总数,
      SUM(od.Quantity*od.UnitPrice) AS 订单总价格
from Orders AS O, [Order Details] AS od
where o.OrderID=od.OrderID
GROUP BY o.EmployeeID
HAVING SUM(od.Quantity*od.UnitPrice)>1000
ORDER BY  SUM(od.Quantity*od.UnitPrice) DESC,COUNT(*) ASC
```
> HAVING是删选条件，对聚合函数只能用having，不能用where

#### 两张以上的表连接查询
```sql
select o.EmployeeID AS 员工编号,
      e.LastName + e.FirstName AS 员工姓名,
      COUNT(*) AS 订单总数,
      SUM(od.Quantity*od.UnitPrice) AS 订单总价格
from Orders AS O, [Order Details] AS od,Employee AS e
where o.OrderID=od.OrderID and e.EmployeeID=o.EmployeeID
GROUP BY o.EmployeeID, e.LastName + e.FirstName 
HAVING SUM(od.Quantity*od.UnitPrice)>1000
ORDER BY  SUM(od.Quantity*od.UnitPrice) DESC,COUNT(*) ASC
```
`注意：使用group by 分组查询时，select子句中非聚合函数的列一定要在group by子句中。
使用having删选条件时，只能包含在聚合函数或group by子句中
where子句不能直接以聚合函数作为搜索条件`





