## 异常的分类
Throwable时所有异常类的父类，异常分为Error和Exception两种类型
##### Error
Error类通常来描述java运行时系统中的内部错误以及资源耗尽错误，一般是指JVM错误。仅靠修改程序本身不能恢复执行，此类被称为致命性异常。

##### Exception
称为非致命性异常。该类型的异常在程序中发生后可以进行捕获，处理后程序正常进行。Exception分为RuntimeException异常（运行时异常）和
Runtime Exception之外的异常（编译时异常）。

##### 异常类型
Exception异常层次结构的父类；NullPointException访问Null对象的方法；IllegalArgumentException接收非法参数；ClassNotFoundException不能加载所需要的类；ArithmetticException算术运算异常，如除数为零；ArrayIndexOutOfBoundsException数组下标小于或大于其长度；InputMisMatchException允许接收的数据类型与实际输入的类型不匹配；NumberFormatException格式化数据异常

##### 异常处理的步骤
> 1.一旦产生异常，首先产生对应异常类的实例对象。<br>
> 2.在try-catch-finally语句中捕获此异常对象。<br>
> 3.产生的异常对象与catch语句中各个异常类型进行匹配，若匹配成功，执行catch语句，否则执行finally语句。
```java
package OOP3;

public class Demo {
	public static void main(String[] args) {
		try {
			int a=50;
			int result=a/0;      //发生异常，生成异常类的实例化对象
		} catch (Exception e) {    //匹配并捕捉异常对象
			e.printStackTrace();      //执行异常处理
		}finally{                   // 异常统一出口
			System.out.println("没有找到匹配的异常");
		}
	}
}

```
```java
package OOP3;

public class ExceptionDemo {
	public static void main(String[] args) {
		System.out.println("开始计算");
		int firstNum=0;
		int secondNum=0;
		try{
			String str1=args[0];
			String str2=args[1];
			firstNum=Integer.parseInt(str1);
			secondNum=Integer.parseInt(str2);
			int result = firstNum/secondNum;  
			System.out.println("两个数字相除为"+result);
		}catch(ArithmeticException e){       
			System.out.println("算术异常");     
		}catch(NumberFormatException e){
			System.out.println("格式化数据异常");
		}catch(Exception e){
			System.out.println("其他异常");
		}
		System.out.println("计算结束");
	}
}

```
> 在多重catch中，异常子类必须放在异常父类之前，否则程序会出现编译错误。

## 使用throw和throws
#### throw 语法
该语法用于手工抛出一个异常对象。
```java
package OOP3;

public class Throw {
	public static void main(String[] args) {
		try {
			String ID=args[0].trim();
			if(ID.length()!=18)
				throw new IllegalArgumentException("非法的身份证编号");
				System.out.println("省份证编号是："+ID);
		} catch (Exception e) {
			System.out.println("程序出现异常");
		}
	}
}

```
结果是：`程序出现异常`
#### 异常声明throws
```java
package OOP3;

public class Computer {
	//div方法后面使用了throws表示div方法可以不处理异常
	public int div(int a,int b) throws Exception{
		//下面进行除法时可能产生异常
		int result=a/b;
		return result;
	}
}
package OOP3;

public class ComputerDemo {
	public static void main(String[] args) {
		Computer computer=new Computer();
		try {
			//因为在定义div方法时使用了throws，所以不管是否有异常都必须处理
			System.out.println("商的结果是："+computer.div(12, 2));
		} catch (Exception e) {
			e.printStackTrace();//打印异常堆栈列表信息
		}
	}
}
//结果显示：商的结果是6
```
无论ComputerDemo代码是否出现问题，在调用时都需要通过try-catch语句块进行异常捕获处理，因为在定义div方法时使用了throws
关键字，将异常抛给方法调用者处理，调用者也可以使用throws关键字将异常抛给上一级方法处理。但由于主方法再向上抛出异常，
则此时只能将异常抛给jvm处理。java中“最顶层”就是jvm。
```java
package OOP3;

public class ComputerDemo {
	//主方法使用了throws，将异常抛给jvm处理
	public static void main(String[] args) throws Exception{
		Computer computer=new Computer();
			System.out.println("商的结果是："+computer.div(12, 2));
		
	}
}
```
##### throw与throws的比较
```
throw                               throws
抛出一个具体的异常类实例      声明一个方法可能抛出的所有异常类型
需要用户自己捕获相关的异常    不用显示捕获异常，可由系统自动将所有捕获的异常信息抛给上级方法
throw在方法内部使用          throws在方法名后面声明
```
## 自定义异常
```java
package OOP3;
//1.自定义异常类可以继承throwable类或Exception，自定义异常类之间也可以有继承关系
public class MyException extends Exception{
	//2.为自定义异常类设计构造方法，以方便构造自定义异常对象
	public MyException(String msg){
		super(msg);
	}

}
package OOP3;

import java.util.Scanner;

//3.在程序中使用自定义异常类
public class Demo2 {
	public static void main(String[] args) throws Exception{
		Scanner scanner = new Scanner(System.in);
		int age=scanner.nextInt();
		if((age<0)||(age>100)){
			throw new MyException("输入的年龄非法");
			
		}
	}
}
```
```
190
Exception in thread "main" OOP3.MyException: 输入的年龄非法
	at OOP3.Demo2.main(Demo2.java:11)
```
## 异常使用细节
（1）一个方法被重写时，重写的方法必须抛出相同的异常类或异常子类。<br>
（2）如果父类抛出多个异常类，则重写方法必须抛出父类方法异常类的一个子集，即不能抛出新的异常。
```java

public class Computer {
	public int div(int a,int b) throws IOException,NullPointerException{
		int result=a/b;
		return result;
	}
}
public class Computer2 extends Computer {
	//不能抛出新的异常
	public int div(int a,int b) throws IOException{
		int result=a/b;
		return result;
	}
}
```
