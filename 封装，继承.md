## 封装
> 封装是类对外隐藏特征和行为的内部实现细节。简而言之，封装就是将类的属性私有化，并提供公有方法访问私有属性的机制。
#### 封装的实现过程
（1）使用private 修饰符私有化类的属性和方法
```java
class Person{
  private int salary;
  private String getInfo(){
  }
}
```
（2）为封装后的属性提供相应的getter/setter 方法；为封装后的私有化方法提供公共方法访问
```java
class   Person{
  private int salary;
  private String getInfo(){
    return "person";
    //使用getter/setter访问
        //访问salary
    public void setSalary(int salary){
    this.salary=salary;
    }
    public  int getSalary(){
    return salary;
    }
        //访问getInfo()方法
        public String showInfo(){
          return getInfo();
        }
  }
  
}
```
（3）在赋值和取值方法中，加入对属性的存取限制`使外部不能随意更改属性信息，保证属性信息的安全`
```java
public void setAge(int age){
  if((age>0) && (age<100))
        this.age = age;
     else
     System.out.println("非法的年龄");
}
```
#### 访问修饰符
从小到大：private，default，protected，public

## 继承
`Java中不允许多继承，即一个子类只允许继承一个父类`
```java
package com.cn.demo;

public class Person {
	public String name="jack";
	public void gerPersonInfo(){
		System.out.println("this is a person");
	}
}
package com.cn.demo;
//建立子类并使用extends关键字继承关系
public class Child extends Person{
	 public void getInfo(){
   System.out.println("this is a child");
   }
   //定义子类对象，使用父类功能
   public static void main(String[] args){
   Child child=new Child();
   //1.子类使用父类的属性
    System.out.println(child.name);
   //2.子类调用父类方法，2,3结果一样，都是this is a person
    child.getPerosonInfo();
    //3.定义子类对象指向子类引用
    Person person=new Person();
    person.getPersonInfo();
 }
 }
 
 
/*
 构造方法的继承（创建子类对象时，会先调用父类的构造方法，在调用子类构造方法）
**/
//定义父类
public Person{
  public String name="Person";
      //定义父类的构造方法
  public Person(){
    System.out.println("this is a person");
  }
}
//定义子类
public class Child extends Person{
  public String name="Child";
    //定义子类的构造方法
    public Child(){
    System.out.println("this is a child");
    }
  public static void main(String[] args){
   Child child=new Child();//创建子类对象
    System.out.println("名字是" + child.name);
   //结果是this is a Person
   //     this is a child
   //     名字是Child
          
   }
} 
```
> 当实例化一个类时会自动调用类的构造方法。同时，如何一个子类继承了父类，那么在创建子类对象时，会先调用父类的构造方法，再调用子类的构造方法。
## Object类
> 如果没有使用extends关键字，那么该类将隐式继承Object类。
#### 继承中父子类的引用和对象的指向关系
```java
public class Person {
	public String name="jack";
	public void printInfo(){
		System.out.println("this is a person");
	}
}
package com.cn.demo;
//建立子类并使用extends关键字继承关系
public class Child extends Person{
	 public void printInfo(){
   	System.out.println("this is a child");
   }
   public static void main(String[] args){
   Person person=new Child();	//1.父类引用指向子类对象
   person.printInfo();//调用子类的方法，结果是this is a child
   Person person=new Person();//2.创建父类对象，调用结果是this is a person
   Child chiild-new Child();//3.创建子类对象，调用结果是this is a child
    }
  }
   
```
## final
> final 修饰的类是最终类，不可以被继承；最终方法不可以被重写；常量必须赋初值且不允许被修改

## this 和 super
（1）this：表示当前类对象本身   		（2）super：表示父类
this.属性； //调用当前对象的属性		    super.属性； //调用父类属性
this.方法();//调用当前对象的方法		     super.方法();//调用父类的方法
this();  //调用当前类的构造方法		      super();  //调用父类的构造方法

```java
class Person{
      public String name="Person";
      public int age=0;
      public Person(){
      	System.out.println("Person类无参构造方法");
      }
      //构造方法重载
      public Person(int age){
      this.age=age;
      }
      public void getInfo(){
      	System.out.println("this is a person");
      }
}
//继承父类
public class Child extends Person(){
    public String name="tom";
    public int age=2;
    public Child(){
        super(90);//调用Person类有参构造方法
	System.out.println("Child类无参构造方法");
    }
    public void Child(int age){
    	this.age=age;
    }
    public void introduce(){
       System.out.println("my name is tom");
    }
    public void getInfo(){
      //调用子类中的同名属性age
      System.out.println(this.age);
      //调用父类中的同名属性
       System.out.println(super.age);
       //调用父类中getInfo()方法
       super.getInfo();
       //调用子类中getInfo()方法
       this.getInfo();
        System.out.println("this is a child");
      
    }
    public static void main(String[] args){
     Child child=new Child();
     child.getInfo();
    }
} 
```
```
结果是：
Child类无参构造方法
2
90
this is a person
my name is tom
this is a child
```
> 1.若父类中只有无参的构造方法，子类可写可不写，都会被隐式调用<br>
> 2.若父类中只有有参的构造方法，子类必须写super（参数），否则报错<br>
> 3.若父类中有参，无参都有，子类不写会自动调用父类无参的构造方法

```
注意：（1）super()语句必须写在子类构造方法的第一行
（2）在一个构造方法中可以用this()调用当前类的其他构造方法，但只能调用一次，并且放在第一行
（3）this()和super()不能同时出现在同一个构造函数中
```




