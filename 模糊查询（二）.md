模糊查询
-------
`LIKE`运算符<br>
`%`通配符，表示任意字符的匹配，且不计字符的多少<br>
`—`通配符，表示与任意字符的匹配，只是它仅表示任意一个字符的匹配<br>
`[]`通配符，用于指定一系列的字符，只要满足这些字符其中之一且出现在`[]`通配符的位置的字符串就满足查询条件<br>
例：从产品表中查询产品名称第二个字符为“e”的产品名称和单价<br>
`selelct  ProductName,UnitPrice from Products where ProductName like '_e%'`<br>
查询产品表中产品名称中包含'_'的产品名称和单价<br>
`selelct  ProductName,UnitPrice from Products where ProductName like '%[_]%'`<br>
查询产品表中产品名称中最后一个字符为“a”，“b”，“c”或“d”的产品名称和单价<br>
`selelct  ProductName,UnitPrice from Products where ProductName like '%[a,b,c,d]'`<br>
查询产品表中产品名称中最后一个字符不为“a”，“b”，“c”或“d”的产品名称和单价<br>
`selelct  ProductName,UnitPrice from Products where ProductName like '%[^a,b,c,d]'`<br>

`IN`运算符<br>
若只需要满足多个条件中的一个查询条件<br>
例：从产品表中查询产品名称和供货编号信息，且供货编号为1,3或4<br>
`select ProductName,DupplierID from Product where SupplierID IN(1,3,4)`<br>
在大多数情况下，OR运算符与IN运算符可以实现相同的功能（in运算符后可以接子查询）<br>
`select ProductName,DupplierID from Product where SupplierID=1 or SupplierID=3 or SupplierID=4`<br>
与OR运算符相比，IN运算符的两个优点<br>
（1）in运算符更加简洁，运行效率高与or运算符<br>
（2）in运算符后面所列的条件可以是另一条select语句，即子查询<br>

between运算符<br>
（1）用于数字类型数据<br>
从产品表中查询单价在6~10之间的产品名称和单价信息<br>
`select   ProuctName,UnitPrice from   Products where  UnitPrice BETWEEN 6 AND 10`<br>
（2）用于时间日期类型数据<br>
从员工表中查询出生日期在1952-09-09到1960-09-09的员工姓名和出生日期<br>
`SELECT LastName,FirstName,BirthDate from Employees where BirthDate BETWEEN '1952-09-09' AND '1960-09-09'`


聚合函数
-------
注：聚合函数不能作为where子句的直接搜索条件<br>
sum 函数<br>
从订单明细表中查询前10行商品的总价格<br>
`select top 10 SUM(UnitPrice*Quantity) as 订单价格 from Products`

MAX/MIN函数<br>
查询单价最高的商品单价<br>
`select MAX(UnitPrice) as 最高单价产品 from Products`

AVG函数<br>
从产品表中查询商品的平均单价<br>
`select AVG(UnitPrice) as 平均单价 from Products`


COUNT()函数<br>
从产品表中查询商品的总行数<br>
`select COUNT(*) as 总数 from Products`

分组查询
--------
group by子句<br>
分组查询是先将记录放在一张临时表里--在临时表中根据聚合函数查找，并将符合条件的记录返回给用户<br>
`注：当group by 子句中用于分组的列中出现了null值时，会将所有的null值分在同一组中，即认为他们是“相等的”`

having 子句<br>
having与where的区别：having子句与组有关，而不是单个的行有关。where子句不能以聚合函数作为搜索条件<br>
（1）从订单表中查询员工编号大于2，订单数在100以上的员工编号和订单数，要求使用having函数<br>
`select Employee,COUNT(*) AS 订单总数 from Orders<br>
GROUP BY Employee HAVING COUNT(*)>100 AND EmployeeID>2`<br>
（2）从订单表中查订单编号大于2，订单数在100以上的员工编号和订单数，要求使用having函数<br>
【错误原因：having中的OrderID没有包含在聚合函数或group by子句中，包括在having子句中的列必须是组列】<br>
`select Employee,COUNT(*) AS 订单总数 from Orders
GROUP BY Employee HAVING COUNT(*)>100 AND OrderID>2`<br>
【正解】<br>
`select Employee,COUNT(*) AS 订单总数 from Orders
where  OrderID>2
GROUP BY Employee HAVING COUNT(*)>100 `






